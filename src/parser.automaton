State 0:
## Known stack suffix:
##
## LR(1) items:
program_rule' -> . program_rule [ # ]
## Transitions:
-- On WHILE shift to state 1
-- On TYPE shift to state 93
-- On RETURN shift to state 121
-- On LET shift to state 125
-- On IF shift to state 145
-- On ID shift to state 148
-- On FUN shift to state 158
-- On CONT shift to state 169
-- On BREAK shift to state 170
-- On BIND shift to state 171
-- On while_loop shift to state 183
-- On udt_def shift to state 184
-- On program_rule shift to state 217
-- On if_stmt shift to state 185
-- On func_def shift to state 186
-- On func_call shift to state 187
-- On declaration shift to state 188
-- On control_flow shift to state 189
-- On block_list shift to state 218
-- On block shift to state 192
-- On assignment shift to state 194
## Reductions:
-- On EOF
--   reduce production block_list ->

State 1:
## Known stack suffix:
## WHILE
## LR(1) items:
while_loop -> WHILE . expr LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 91
## Reductions:

State 2:
## Known stack suffix:
## UNIT
## LR(1) items:
expr -> UNIT . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> UNIT

State 3:
## Known stack suffix:
## SLIT
## LR(1) items:
expr -> SLIT . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> SLIT

State 4:
## Known stack suffix:
## NOT
## LR(1) items:
expr -> NOT . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 90
## Reductions:

State 5:
## Known stack suffix:
## MATCH
## LR(1) items:
expr -> MATCH . expr LBRACE case_list RBRACE [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 73
## Reductions:

State 6:
## Known stack suffix:
## LPAREN
## LR(1) items:
expr -> LPAREN . expr RPAREN [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
tuple -> LPAREN . list_elements RPAREN [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On list_elements shift to state 69
-- On expr shift to state 71
## Reductions:
-- On RPAREN
--   reduce production list_elements ->

State 7:
## Known stack suffix:
## LITERAL
## LR(1) items:
expr -> LITERAL . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> LITERAL

State 8:
## Known stack suffix:
## LBRACKET
## LR(1) items:
src_parser_list -> LBRACKET . list_elements RBRACKET [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On list_elements shift to state 64
-- On expr shift to state 66
## Reductions:
-- On RBRACKET
--   reduce production list_elements ->

State 9:
## Known stack suffix:
## INCR
## LR(1) items:
expr -> INCR . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 63
## Reductions:

State 10:
## Known stack suffix:
## ID
## LR(1) items:
expr -> ID . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> ID . LBRACKET expr RBRACKET [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> ID . DOT ID [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
udt_instance -> ID . LBRACE udt_contents RBRACE [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On LBRACKET shift to state 11
-- On LBRACE shift to state 52
-- On DOT shift to state 61
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> ID
** Conflict on LBRACE

State 11:
## Known stack suffix:
## ID LBRACKET
## LR(1) items:
expr -> ID LBRACKET . expr RBRACKET [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 50
## Reductions:

State 12:
## Known stack suffix:
## FLIT
## LR(1) items:
expr -> FLIT . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> FLIT

State 13:
## Known stack suffix:
## DECR
## LR(1) items:
expr -> DECR . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 19
## Reductions:

State 14:
## Known stack suffix:
## CLIT
## LR(1) items:
expr -> CLIT . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> CLIT

State 15:
## Known stack suffix:
## BLIT
## LR(1) items:
expr -> BLIT . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> BLIT

State 16:
## Known stack suffix:
## udt_instance
## LR(1) items:
expr -> udt_instance . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> udt_instance

State 17:
## Known stack suffix:
## tuple
## LR(1) items:
expr -> tuple . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> tuple

State 18:
## Known stack suffix:
## src_parser_list
## LR(1) items:
expr -> src_parser_list . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> src_parser_list

State 19:
## Known stack suffix:
## DECR expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> DECR expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> DECR expr
** Conflict on TIMES PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND

State 20:
## Known stack suffix:
## expr TIMES
## LR(1) items:
expr -> expr TIMES . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 21
## Reductions:

State 21:
## Known stack suffix:
## expr TIMES expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr TIMES expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On MODULO shift to state 22
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> expr TIMES expr
** Conflict on MODULO INCR DECR

State 22:
## Known stack suffix:
## expr MODULO
## LR(1) items:
expr -> expr MODULO . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 23
## Reductions:

State 23:
## Known stack suffix:
## expr MODULO expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr MODULO expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> expr MODULO expr
** Conflict on TIMES PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND

State 24:
## Known stack suffix:
## expr PLUS
## LR(1) items:
expr -> expr PLUS . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 25
## Reductions:

State 25:
## Known stack suffix:
## expr PLUS expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr PLUS expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On MODULO shift to state 22
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EOF DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> expr PLUS expr
** Conflict on MODULO INCR DECR

State 26:
## Known stack suffix:
## expr INCR
## LR(1) items:
expr -> expr INCR . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> expr INCR

State 27:
## Known stack suffix:
## expr EXPONENT
## LR(1) items:
expr -> expr EXPONENT . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 28
## Reductions:

State 28:
## Known stack suffix:
## expr EXPONENT expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr EXPONENT expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On MODULO shift to state 22
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> expr EXPONENT expr
** Conflict on MODULO INCR DECR

State 29:
## Known stack suffix:
## expr DECR
## LR(1) items:
expr -> expr DECR . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> expr DECR

State 30:
## Known stack suffix:
## expr DIVIDE
## LR(1) items:
expr -> expr DIVIDE . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 31
## Reductions:

State 31:
## Known stack suffix:
## expr DIVIDE expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr DIVIDE expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On MODULO shift to state 22
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> expr DIVIDE expr
** Conflict on MODULO INCR DECR

State 32:
## Known stack suffix:
## expr OR
## LR(1) items:
expr -> expr OR . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 33
## Reductions:

State 33:
## Known stack suffix:
## expr OR expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr OR expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND
--   reduce production expr -> expr OR expr
** Conflict on MODULO INCR DECR

State 34:
## Known stack suffix:
## expr NEQ
## LR(1) items:
expr -> expr NEQ . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 35
## Reductions:

State 35:
## Known stack suffix:
## expr NEQ expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr NEQ expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND AND
--   reduce production expr -> expr NEQ expr
** Conflict on MODULO INCR DECR

State 36:
## Known stack suffix:
## expr MINUS
## LR(1) items:
expr -> expr MINUS . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 37
## Reductions:

State 37:
## Known stack suffix:
## expr MINUS expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr MINUS expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On MODULO shift to state 22
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EOF DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> expr MINUS expr
** Conflict on MODULO INCR DECR

State 38:
## Known stack suffix:
## expr LT
## LR(1) items:
expr -> expr LT . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 39
## Reductions:

State 39:
## Known stack suffix:
## expr LT expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr LT expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND AND
--   reduce production expr -> expr LT expr
** Conflict on MODULO INCR DECR

State 40:
## Known stack suffix:
## expr LEQ
## LR(1) items:
expr -> expr LEQ . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 41
## Reductions:

State 41:
## Known stack suffix:
## expr LEQ expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr LEQ expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND AND
--   reduce production expr -> expr LEQ expr
** Conflict on MODULO INCR DECR

State 42:
## Known stack suffix:
## expr GT
## LR(1) items:
expr -> expr GT . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 43
## Reductions:

State 43:
## Known stack suffix:
## expr GT expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr GT expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND AND
--   reduce production expr -> expr GT expr
** Conflict on MODULO INCR DECR

State 44:
## Known stack suffix:
## expr GEQ
## LR(1) items:
expr -> expr GEQ . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 45
## Reductions:

State 45:
## Known stack suffix:
## expr GEQ expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr GEQ expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND AND
--   reduce production expr -> expr GEQ expr
** Conflict on MODULO INCR DECR

State 46:
## Known stack suffix:
## expr BEQ
## LR(1) items:
expr -> expr BEQ . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 47
## Reductions:

State 47:
## Known stack suffix:
## expr BEQ expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr BEQ expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On INCR shift to state 26
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND AND
--   reduce production expr -> expr BEQ expr
** Conflict on MODULO INCR DECR

State 48:
## Known stack suffix:
## expr AND
## LR(1) items:
expr -> expr AND . expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 49
## Reductions:

State 49:
## Known stack suffix:
## expr AND expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr AND expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND AND
--   reduce production expr -> expr AND expr
** Conflict on MODULO INCR DECR

State 50:
## Known stack suffix:
## ID LBRACKET expr
## LR(1) items:
expr -> expr . PLUS expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> ID LBRACKET expr . RBRACKET [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On RBRACKET shift to state 51
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 51:
## Known stack suffix:
## ID LBRACKET expr RBRACKET
## LR(1) items:
expr -> ID LBRACKET expr RBRACKET . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> ID LBRACKET expr RBRACKET

State 52:
## Known stack suffix:
## ID LBRACE
## LR(1) items:
udt_instance -> ID LBRACE . udt_contents RBRACE [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On ID shift to state 53
-- On udt_element shift to state 56
-- On udt_contents shift to state 59
## Reductions:

State 53:
## Known stack suffix:
## ID
## LR(1) items:
udt_element -> ID . COLON expr [ RBRACE COMMA ]
## Transitions:
-- On COLON shift to state 54
## Reductions:

State 54:
## Known stack suffix:
## ID COLON
## LR(1) items:
udt_element -> ID COLON . expr [ RBRACE COMMA ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 55
## Reductions:

State 55:
## Known stack suffix:
## ID COLON expr
## LR(1) items:
expr -> expr . PLUS expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . MINUS expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . TIMES expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . MODULO expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . INCR [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . DECR [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . BEQ expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . NEQ expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . LT expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . LEQ expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . GT expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . GEQ expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . AND expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . OR expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
udt_element -> ID COLON expr . [ RBRACE COMMA ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On RBRACE COMMA
--   reduce production udt_element -> ID COLON expr

State 56:
## Known stack suffix:
## udt_element
## LR(1) items:
udt_contents -> udt_element . [ RBRACE ]
udt_contents -> udt_element . COMMA udt_contents [ RBRACE ]
## Transitions:
-- On COMMA shift to state 57
## Reductions:
-- On RBRACE
--   reduce production udt_contents -> udt_element

State 57:
## Known stack suffix:
## udt_element COMMA
## LR(1) items:
udt_contents -> udt_element COMMA . udt_contents [ RBRACE ]
## Transitions:
-- On ID shift to state 53
-- On udt_element shift to state 56
-- On udt_contents shift to state 58
## Reductions:

State 58:
## Known stack suffix:
## udt_element COMMA udt_contents
## LR(1) items:
udt_contents -> udt_element COMMA udt_contents . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production udt_contents -> udt_element COMMA udt_contents

State 59:
## Known stack suffix:
## ID LBRACE udt_contents
## LR(1) items:
udt_instance -> ID LBRACE udt_contents . RBRACE [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On RBRACE shift to state 60
## Reductions:

State 60:
## Known stack suffix:
## ID LBRACE udt_contents RBRACE
## LR(1) items:
udt_instance -> ID LBRACE udt_contents RBRACE . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production udt_instance -> ID LBRACE udt_contents RBRACE

State 61:
## Known stack suffix:
## ID DOT
## LR(1) items:
expr -> ID DOT . ID [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On ID shift to state 62
## Reductions:

State 62:
## Known stack suffix:
## ID DOT ID
## LR(1) items:
expr -> ID DOT ID . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> ID DOT ID

State 63:
## Known stack suffix:
## INCR expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> INCR expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> INCR expr
** Conflict on TIMES PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND

State 64:
## Known stack suffix:
## LBRACKET list_elements
## LR(1) items:
src_parser_list -> LBRACKET list_elements . RBRACKET [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On RBRACKET shift to state 65
## Reductions:

State 65:
## Known stack suffix:
## LBRACKET list_elements RBRACKET
## LR(1) items:
src_parser_list -> LBRACKET list_elements RBRACKET . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production src_parser_list -> LBRACKET list_elements RBRACKET

State 66:
## Known stack suffix:
## expr
## LR(1) items:
expr -> expr . PLUS expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . MINUS expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . TIMES expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . MODULO expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . INCR [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . DECR [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . BEQ expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . NEQ expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . LT expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . LEQ expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . GT expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . GEQ expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . AND expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . OR expr [ TIMES RPAREN RBRACKET PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
list_elements -> expr . [ RPAREN RBRACKET ]
list_elements -> expr . COMMA list_elements [ RPAREN RBRACKET ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On COMMA shift to state 67
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On RPAREN RBRACKET
--   reduce production list_elements -> expr

State 67:
## Known stack suffix:
## expr COMMA
## LR(1) items:
list_elements -> expr COMMA . list_elements [ RPAREN RBRACKET ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On list_elements shift to state 68
-- On expr shift to state 66
## Reductions:
-- On RPAREN RBRACKET
--   reduce production list_elements ->

State 68:
## Known stack suffix:
## expr COMMA list_elements
## LR(1) items:
list_elements -> expr COMMA list_elements . [ RPAREN RBRACKET ]
## Transitions:
## Reductions:
-- On RPAREN RBRACKET
--   reduce production list_elements -> expr COMMA list_elements

State 69:
## Known stack suffix:
## LPAREN list_elements
## LR(1) items:
tuple -> LPAREN list_elements . RPAREN [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On RPAREN shift to state 70
## Reductions:

State 70:
## Known stack suffix:
## LPAREN list_elements RPAREN
## LR(1) items:
tuple -> LPAREN list_elements RPAREN . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production tuple -> LPAREN list_elements RPAREN

State 71:
## Known stack suffix:
## LPAREN expr
## LR(1) items:
expr -> expr . PLUS expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . MINUS expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . TIMES expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . MODULO expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . INCR [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . DECR [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . BEQ expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . NEQ expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . LT expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . LEQ expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . GT expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . GEQ expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . AND expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . OR expr [ TIMES RPAREN PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> LPAREN expr . RPAREN [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
list_elements -> expr . [ RPAREN ]
list_elements -> expr . COMMA list_elements [ RPAREN ]
## Transitions:
-- On TIMES shift to state 20
-- On RPAREN shift to state 72
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On COMMA shift to state 67
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On RPAREN
--   reduce production list_elements -> expr
** Conflict on RPAREN

State 72:
## Known stack suffix:
## LPAREN expr RPAREN
## LR(1) items:
expr -> LPAREN expr RPAREN . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> LPAREN expr RPAREN

State 73:
## Known stack suffix:
## MATCH expr
## LR(1) items:
expr -> expr . PLUS expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> MATCH expr . LBRACE case_list RBRACE [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On LBRACE shift to state 74
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 74:
## Known stack suffix:
## MATCH expr LBRACE
## LR(1) items:
expr -> MATCH expr LBRACE . case_list RBRACE [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On UNDERSCORE shift to state 75
-- On SLIT shift to state 76
-- On LITERAL shift to state 77
-- On ID shift to state 78
-- On FLIT shift to state 79
-- On CLIT shift to state 80
-- On BLIT shift to state 81
-- On pattern shift to state 82
-- On case_list shift to state 85
-- On case_item shift to state 87
## Reductions:

State 75:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
pattern -> UNDERSCORE . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production pattern -> UNDERSCORE

State 76:
## Known stack suffix:
## SLIT
## LR(1) items:
pattern -> SLIT . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production pattern -> SLIT

State 77:
## Known stack suffix:
## LITERAL
## LR(1) items:
pattern -> LITERAL . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production pattern -> LITERAL

State 78:
## Known stack suffix:
## ID
## LR(1) items:
pattern -> ID . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production pattern -> ID

State 79:
## Known stack suffix:
## FLIT
## LR(1) items:
pattern -> FLIT . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production pattern -> FLIT

State 80:
## Known stack suffix:
## CLIT
## LR(1) items:
pattern -> CLIT . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production pattern -> CLIT

State 81:
## Known stack suffix:
## BLIT
## LR(1) items:
pattern -> BLIT . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production pattern -> BLIT

State 82:
## Known stack suffix:
## pattern
## LR(1) items:
case_item -> pattern . ARROW expr [ RBRACE COMMA ]
## Transitions:
-- On ARROW shift to state 83
## Reductions:

State 83:
## Known stack suffix:
## pattern ARROW
## LR(1) items:
case_item -> pattern ARROW . expr [ RBRACE COMMA ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 84
## Reductions:

State 84:
## Known stack suffix:
## pattern ARROW expr
## LR(1) items:
case_item -> pattern ARROW expr . [ RBRACE COMMA ]
expr -> expr . PLUS expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . MINUS expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . TIMES expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . MODULO expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . INCR [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . DECR [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . BEQ expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . NEQ expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . LT expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . LEQ expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . GT expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . GEQ expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . AND expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
expr -> expr . OR expr [ TIMES RBRACE PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR COMMA BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On RBRACE COMMA
--   reduce production case_item -> pattern ARROW expr

State 85:
## Known stack suffix:
## MATCH expr LBRACE case_list
## LR(1) items:
expr -> MATCH expr LBRACE case_list . RBRACE [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On RBRACE shift to state 86
## Reductions:

State 86:
## Known stack suffix:
## MATCH expr LBRACE case_list RBRACE
## LR(1) items:
expr -> MATCH expr LBRACE case_list RBRACE . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
## Reductions:
-- On WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND
--   reduce production expr -> MATCH expr LBRACE case_list RBRACE

State 87:
## Known stack suffix:
## case_item
## LR(1) items:
case_list -> case_item . [ RBRACE ]
case_list -> case_item . COMMA case_list [ RBRACE ]
## Transitions:
-- On COMMA shift to state 88
## Reductions:
-- On RBRACE
--   reduce production case_list -> case_item

State 88:
## Known stack suffix:
## case_item COMMA
## LR(1) items:
case_list -> case_item COMMA . case_list [ RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 75
-- On SLIT shift to state 76
-- On LITERAL shift to state 77
-- On ID shift to state 78
-- On FLIT shift to state 79
-- On CLIT shift to state 80
-- On BLIT shift to state 81
-- On pattern shift to state 82
-- On case_list shift to state 89
-- On case_item shift to state 87
## Reductions:

State 89:
## Known stack suffix:
## case_item COMMA case_list
## LR(1) items:
case_list -> case_item COMMA case_list . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production case_list -> case_item COMMA case_list

State 90:
## Known stack suffix:
## NOT expr
## LR(1) items:
expr -> expr . PLUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
expr -> NOT expr . [ WHILE TYPE TIMES SEMI RPAREN RETURN RBRACKET RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ LBRACE INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT COMMA BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
## Reductions:
-- On WHILE TYPE SEMI RPAREN RETURN RBRACKET RBRACE OR MODULO LET LBRACE INCR IF ID FUN EOF DECR CONT COMMA BREAK BIND AND
--   reduce production expr -> NOT expr
** Conflict on MODULO INCR DECR

State 91:
## Known stack suffix:
## WHILE expr
## LR(1) items:
expr -> expr . PLUS expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
while_loop -> WHILE expr . LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On LBRACE shift to state 92
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 92:
## Known stack suffix:
## WHILE expr LBRACE
## LR(1) items:
while_loop -> WHILE expr LBRACE . block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On WHILE shift to state 1
-- On TYPE shift to state 93
-- On RETURN shift to state 121
-- On LET shift to state 125
-- On IF shift to state 145
-- On ID shift to state 148
-- On FUN shift to state 158
-- On CONT shift to state 169
-- On BREAK shift to state 170
-- On BIND shift to state 171
-- On while_loop shift to state 183
-- On udt_def shift to state 184
-- On if_stmt shift to state 185
-- On func_def shift to state 186
-- On func_call shift to state 187
-- On declaration shift to state 188
-- On control_flow shift to state 189
-- On block_list shift to state 215
-- On block shift to state 192
-- On assignment shift to state 194
## Reductions:
-- On RBRACE
--   reduce production block_list ->

State 93:
## Known stack suffix:
## TYPE
## LR(1) items:
udt_def -> TYPE . ID LBRACE udt_members RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ID shift to state 94
## Reductions:

State 94:
## Known stack suffix:
## TYPE ID
## LR(1) items:
udt_def -> TYPE ID . LBRACE udt_members RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On LBRACE shift to state 95
## Reductions:

State 95:
## Known stack suffix:
## TYPE ID LBRACE
## LR(1) items:
udt_def -> TYPE ID LBRACE . udt_members RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ID shift to state 96
-- On udt_members shift to state 119
## Reductions:

State 96:
## Known stack suffix:
## ID
## LR(1) items:
udt_members -> ID . COLON typ [ RBRACE ]
udt_members -> ID . COLON typ COMMA udt_members [ RBRACE ]
## Transitions:
-- On COLON shift to state 97
## Reductions:

State 97:
## Known stack suffix:
## ID COLON
## LR(1) items:
udt_members -> ID COLON . typ [ RBRACE ]
udt_members -> ID COLON . typ COMMA udt_members [ RBRACE ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 116
## Reductions:

State 98:
## Known stack suffix:
## UNIT
## LR(1) items:
typ -> UNIT . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> UNIT

State 99:
## Known stack suffix:
## TUPLE
## LR(1) items:
typ -> TUPLE . LT typ_list GT [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
-- On LT shift to state 100
## Reductions:

State 100:
## Known stack suffix:
## TUPLE LT
## LR(1) items:
typ -> TUPLE LT . typ_list GT [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ_list shift to state 111
-- On typ shift to state 113
## Reductions:

State 101:
## Known stack suffix:
## STRING
## LR(1) items:
typ -> STRING . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> STRING

State 102:
## Known stack suffix:
## LIST
## LR(1) items:
typ -> LIST . LT typ GT [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
-- On LT shift to state 103
## Reductions:

State 103:
## Known stack suffix:
## LIST LT
## LR(1) items:
typ -> LIST LT . typ GT [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 109
## Reductions:

State 104:
## Known stack suffix:
## INT
## LR(1) items:
typ -> INT . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> INT

State 105:
## Known stack suffix:
## ID
## LR(1) items:
typ -> ID . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> ID

State 106:
## Known stack suffix:
## FLOAT
## LR(1) items:
typ -> FLOAT . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> FLOAT

State 107:
## Known stack suffix:
## CHAR
## LR(1) items:
typ -> CHAR . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> CHAR

State 108:
## Known stack suffix:
## BOOL
## LR(1) items:
typ -> BOOL . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> BOOL

State 109:
## Known stack suffix:
## LIST LT typ
## LR(1) items:
typ -> LIST LT typ . GT [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
-- On GT shift to state 110
## Reductions:

State 110:
## Known stack suffix:
## LIST LT typ GT
## LR(1) items:
typ -> LIST LT typ GT . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> LIST LT typ GT

State 111:
## Known stack suffix:
## TUPLE LT typ_list
## LR(1) items:
typ -> TUPLE LT typ_list . GT [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
-- On GT shift to state 112
## Reductions:

State 112:
## Known stack suffix:
## TUPLE LT typ_list GT
## LR(1) items:
typ -> TUPLE LT typ_list GT . [ RPAREN RBRACE LBRACE GT EQUAL COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACE LBRACE GT EQUAL COMMA
--   reduce production typ -> TUPLE LT typ_list GT

State 113:
## Known stack suffix:
## typ
## LR(1) items:
typ_list -> typ . [ GT ]
typ_list -> typ . COMMA typ_list [ GT ]
## Transitions:
-- On COMMA shift to state 114
## Reductions:
-- On GT
--   reduce production typ_list -> typ

State 114:
## Known stack suffix:
## typ COMMA
## LR(1) items:
typ_list -> typ COMMA . typ_list [ GT ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ_list shift to state 115
-- On typ shift to state 113
## Reductions:

State 115:
## Known stack suffix:
## typ COMMA typ_list
## LR(1) items:
typ_list -> typ COMMA typ_list . [ GT ]
## Transitions:
## Reductions:
-- On GT
--   reduce production typ_list -> typ COMMA typ_list

State 116:
## Known stack suffix:
## ID COLON typ
## LR(1) items:
udt_members -> ID COLON typ . [ RBRACE ]
udt_members -> ID COLON typ . COMMA udt_members [ RBRACE ]
## Transitions:
-- On COMMA shift to state 117
## Reductions:
-- On RBRACE
--   reduce production udt_members -> ID COLON typ

State 117:
## Known stack suffix:
## ID COLON typ COMMA
## LR(1) items:
udt_members -> ID COLON typ COMMA . udt_members [ RBRACE ]
## Transitions:
-- On ID shift to state 96
-- On udt_members shift to state 118
## Reductions:

State 118:
## Known stack suffix:
## ID COLON typ COMMA udt_members
## LR(1) items:
udt_members -> ID COLON typ COMMA udt_members . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production udt_members -> ID COLON typ COMMA udt_members

State 119:
## Known stack suffix:
## TYPE ID LBRACE udt_members
## LR(1) items:
udt_def -> TYPE ID LBRACE udt_members . RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RBRACE shift to state 120
## Reductions:

State 120:
## Known stack suffix:
## TYPE ID LBRACE udt_members RBRACE
## LR(1) items:
udt_def -> TYPE ID LBRACE udt_members RBRACE . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production udt_def -> TYPE ID LBRACE udt_members RBRACE

State 121:
## Known stack suffix:
## RETURN
## LR(1) items:
control_flow -> RETURN . SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
control_flow -> RETURN . expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On SEMI shift to state 122
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 123
## Reductions:

State 122:
## Known stack suffix:
## RETURN SEMI
## LR(1) items:
control_flow -> RETURN SEMI . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production control_flow -> RETURN SEMI

State 123:
## Known stack suffix:
## RETURN expr
## LR(1) items:
control_flow -> RETURN expr . SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On SEMI shift to state 124
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 124:
## Known stack suffix:
## RETURN expr SEMI
## LR(1) items:
control_flow -> RETURN expr SEMI . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production control_flow -> RETURN expr SEMI

State 125:
## Known stack suffix:
## LET
## LR(1) items:
declaration -> LET . MUT ID COLON typ EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
declaration -> LET . MUT ID WALRUS expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
declaration -> LET . ID COLON typ EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
declaration -> LET . ID WALRUS expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On MUT shift to state 126
-- On ID shift to state 136
## Reductions:

State 126:
## Known stack suffix:
## LET MUT
## LR(1) items:
declaration -> LET MUT . ID COLON typ EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
declaration -> LET MUT . ID WALRUS expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ID shift to state 127
## Reductions:

State 127:
## Known stack suffix:
## LET MUT ID
## LR(1) items:
declaration -> LET MUT ID . COLON typ EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
declaration -> LET MUT ID . WALRUS expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On WALRUS shift to state 128
-- On COLON shift to state 131
## Reductions:

State 128:
## Known stack suffix:
## LET MUT ID WALRUS
## LR(1) items:
declaration -> LET MUT ID WALRUS . expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 129
## Reductions:

State 129:
## Known stack suffix:
## LET MUT ID WALRUS expr
## LR(1) items:
declaration -> LET MUT ID WALRUS expr . SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On SEMI shift to state 130
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 130:
## Known stack suffix:
## LET MUT ID WALRUS expr SEMI
## LR(1) items:
declaration -> LET MUT ID WALRUS expr SEMI . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production declaration -> LET MUT ID WALRUS expr SEMI

State 131:
## Known stack suffix:
## LET MUT ID COLON
## LR(1) items:
declaration -> LET MUT ID COLON . typ EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 132
## Reductions:

State 132:
## Known stack suffix:
## LET MUT ID COLON typ
## LR(1) items:
declaration -> LET MUT ID COLON typ . EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On EQUAL shift to state 133
## Reductions:

State 133:
## Known stack suffix:
## LET MUT ID COLON typ EQUAL
## LR(1) items:
declaration -> LET MUT ID COLON typ EQUAL . expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 134
## Reductions:

State 134:
## Known stack suffix:
## LET MUT ID COLON typ EQUAL expr
## LR(1) items:
declaration -> LET MUT ID COLON typ EQUAL expr . SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On SEMI shift to state 135
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 135:
## Known stack suffix:
## LET MUT ID COLON typ EQUAL expr SEMI
## LR(1) items:
declaration -> LET MUT ID COLON typ EQUAL expr SEMI . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production declaration -> LET MUT ID COLON typ EQUAL expr SEMI

State 136:
## Known stack suffix:
## LET ID
## LR(1) items:
declaration -> LET ID . COLON typ EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
declaration -> LET ID . WALRUS expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On WALRUS shift to state 137
-- On COLON shift to state 140
## Reductions:

State 137:
## Known stack suffix:
## LET ID WALRUS
## LR(1) items:
declaration -> LET ID WALRUS . expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 138
## Reductions:

State 138:
## Known stack suffix:
## LET ID WALRUS expr
## LR(1) items:
declaration -> LET ID WALRUS expr . SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On SEMI shift to state 139
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 139:
## Known stack suffix:
## LET ID WALRUS expr SEMI
## LR(1) items:
declaration -> LET ID WALRUS expr SEMI . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production declaration -> LET ID WALRUS expr SEMI

State 140:
## Known stack suffix:
## LET ID COLON
## LR(1) items:
declaration -> LET ID COLON . typ EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 141
## Reductions:

State 141:
## Known stack suffix:
## LET ID COLON typ
## LR(1) items:
declaration -> LET ID COLON typ . EQUAL expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On EQUAL shift to state 142
## Reductions:

State 142:
## Known stack suffix:
## LET ID COLON typ EQUAL
## LR(1) items:
declaration -> LET ID COLON typ EQUAL . expr SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 143
## Reductions:

State 143:
## Known stack suffix:
## LET ID COLON typ EQUAL expr
## LR(1) items:
declaration -> LET ID COLON typ EQUAL expr . SEMI [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MODULO MINUS LT LEQ INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On SEMI shift to state 144
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 144:
## Known stack suffix:
## LET ID COLON typ EQUAL expr SEMI
## LR(1) items:
declaration -> LET ID COLON typ EQUAL expr SEMI . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production declaration -> LET ID COLON typ EQUAL expr SEMI

State 145:
## Known stack suffix:
## IF
## LR(1) items:
if_stmt -> IF . expr LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
if_stmt -> IF . expr LBRACE block_list RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 146
## Reductions:

State 146:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . PLUS expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
if_stmt -> IF expr . LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
if_stmt -> IF expr . LBRACE block_list RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On LBRACE shift to state 147
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 147:
## Known stack suffix:
## IF expr LBRACE
## LR(1) items:
if_stmt -> IF expr LBRACE . block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
if_stmt -> IF expr LBRACE . block_list RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On WHILE shift to state 1
-- On TYPE shift to state 93
-- On RETURN shift to state 121
-- On LET shift to state 125
-- On IF shift to state 145
-- On ID shift to state 148
-- On FUN shift to state 158
-- On CONT shift to state 169
-- On BREAK shift to state 170
-- On BIND shift to state 171
-- On while_loop shift to state 183
-- On udt_def shift to state 184
-- On if_stmt shift to state 185
-- On func_def shift to state 186
-- On func_call shift to state 187
-- On declaration shift to state 188
-- On control_flow shift to state 189
-- On block_list shift to state 202
-- On block shift to state 192
-- On assignment shift to state 194
## Reductions:
-- On RBRACE
--   reduce production block_list ->

State 148:
## Known stack suffix:
## ID
## LR(1) items:
assignment -> ID . EQUAL expr [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
assignment -> ID . PLUS_ASSIGN expr [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
assignment -> ID . MINUS_ASSIGN expr [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
func_call -> ID . LPAREN list_elements RPAREN [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On PLUS_ASSIGN shift to state 149
-- On MINUS_ASSIGN shift to state 151
-- On LPAREN shift to state 153
-- On EQUAL shift to state 156
## Reductions:

State 149:
## Known stack suffix:
## ID PLUS_ASSIGN
## LR(1) items:
assignment -> ID PLUS_ASSIGN . expr [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 150
## Reductions:

State 150:
## Known stack suffix:
## ID PLUS_ASSIGN expr
## LR(1) items:
assignment -> ID PLUS_ASSIGN expr . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production assignment -> ID PLUS_ASSIGN expr

State 151:
## Known stack suffix:
## ID MINUS_ASSIGN
## LR(1) items:
assignment -> ID MINUS_ASSIGN . expr [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 152
## Reductions:

State 152:
## Known stack suffix:
## ID MINUS_ASSIGN expr
## LR(1) items:
assignment -> ID MINUS_ASSIGN expr . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production assignment -> ID MINUS_ASSIGN expr

State 153:
## Known stack suffix:
## ID LPAREN
## LR(1) items:
func_call -> ID LPAREN . list_elements RPAREN [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On list_elements shift to state 154
-- On expr shift to state 66
## Reductions:
-- On RPAREN
--   reduce production list_elements ->

State 154:
## Known stack suffix:
## ID LPAREN list_elements
## LR(1) items:
func_call -> ID LPAREN list_elements . RPAREN [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RPAREN shift to state 155
## Reductions:

State 155:
## Known stack suffix:
## ID LPAREN list_elements RPAREN
## LR(1) items:
func_call -> ID LPAREN list_elements RPAREN . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production func_call -> ID LPAREN list_elements RPAREN

State 156:
## Known stack suffix:
## ID EQUAL
## LR(1) items:
assignment -> ID EQUAL . expr [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 157
## Reductions:

State 157:
## Known stack suffix:
## ID EQUAL expr
## LR(1) items:
assignment -> ID EQUAL expr . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . MINUS expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . TIMES expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . DIVIDE expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . MODULO expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . EXPONENT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . INCR [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . DECR [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . BEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . NEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . LT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . LEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . GT expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . GEQ expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . AND expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
expr -> expr . OR expr [ WHILE TYPE TIMES RETURN RBRACE PLUS OR NEQ MODULO MINUS LT LET LEQ INCR IF ID GT GEQ FUN EXPONENT EOF DIVIDE DECR CONT BREAK BIND BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production assignment -> ID EQUAL expr

State 158:
## Known stack suffix:
## FUN
## LR(1) items:
func_def -> FUN . ID LPAREN formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ID shift to state 159
## Reductions:

State 159:
## Known stack suffix:
## FUN ID
## LR(1) items:
func_def -> FUN ID . LPAREN formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On LPAREN shift to state 160
## Reductions:

State 160:
## Known stack suffix:
## FUN ID LPAREN
## LR(1) items:
func_def -> FUN ID LPAREN . formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ID shift to state 161
-- On formals_opt shift to state 164
-- On formal_list shift to state 195
## Reductions:
-- On RPAREN
--   reduce production formals_opt ->

State 161:
## Known stack suffix:
## ID
## LR(1) items:
formal_list -> ID . COLON typ [ RPAREN COMMA ]
## Transitions:
-- On COLON shift to state 162
## Reductions:

State 162:
## Known stack suffix:
## ID COLON
## LR(1) items:
formal_list -> ID COLON . typ [ RPAREN COMMA ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 163
## Reductions:

State 163:
## Known stack suffix:
## ID COLON typ
## LR(1) items:
formal_list -> ID COLON typ . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production formal_list -> ID COLON typ

State 164:
## Known stack suffix:
## FUN ID LPAREN formals_opt
## LR(1) items:
func_def -> FUN ID LPAREN formals_opt . RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RPAREN shift to state 165
## Reductions:

State 165:
## Known stack suffix:
## FUN ID LPAREN formals_opt RPAREN
## LR(1) items:
func_def -> FUN ID LPAREN formals_opt RPAREN . ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ARROW shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## FUN ID LPAREN formals_opt RPAREN ARROW
## LR(1) items:
func_def -> FUN ID LPAREN formals_opt RPAREN ARROW . typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 167
## Reductions:

State 167:
## Known stack suffix:
## FUN ID LPAREN formals_opt RPAREN ARROW typ
## LR(1) items:
func_def -> FUN ID LPAREN formals_opt RPAREN ARROW typ . LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On LBRACE shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## FUN ID LPAREN formals_opt RPAREN ARROW typ LBRACE
## LR(1) items:
func_def -> FUN ID LPAREN formals_opt RPAREN ARROW typ LBRACE . block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On WHILE shift to state 1
-- On TYPE shift to state 93
-- On RETURN shift to state 121
-- On LET shift to state 125
-- On IF shift to state 145
-- On ID shift to state 148
-- On FUN shift to state 158
-- On CONT shift to state 169
-- On BREAK shift to state 170
-- On BIND shift to state 171
-- On while_loop shift to state 183
-- On udt_def shift to state 184
-- On if_stmt shift to state 185
-- On func_def shift to state 186
-- On func_call shift to state 187
-- On declaration shift to state 188
-- On control_flow shift to state 189
-- On block_list shift to state 200
-- On block shift to state 192
-- On assignment shift to state 194
## Reductions:
-- On RBRACE
--   reduce production block_list ->

State 169:
## Known stack suffix:
## CONT
## LR(1) items:
control_flow -> CONT . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production control_flow -> CONT

State 170:
## Known stack suffix:
## BREAK
## LR(1) items:
control_flow -> BREAK . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production control_flow -> BREAK

State 171:
## Known stack suffix:
## BIND
## LR(1) items:
func_def -> BIND . ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ID shift to state 172
## Reductions:

State 172:
## Known stack suffix:
## BIND ID
## LR(1) items:
func_def -> BIND ID . LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On LT shift to state 173
## Reductions:

State 173:
## Known stack suffix:
## BIND ID LT
## LR(1) items:
func_def -> BIND ID LT . typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 174
## Reductions:

State 174:
## Known stack suffix:
## BIND ID LT typ
## LR(1) items:
func_def -> BIND ID LT typ . GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On GT shift to state 175
## Reductions:

State 175:
## Known stack suffix:
## BIND ID LT typ GT
## LR(1) items:
func_def -> BIND ID LT typ GT . LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On LPAREN shift to state 176
## Reductions:

State 176:
## Known stack suffix:
## BIND ID LT typ GT LPAREN
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN . SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On SELF shift to state 177
## Reductions:

State 177:
## Known stack suffix:
## BIND ID LT typ GT LPAREN SELF
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN SELF . formals_opt RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ID shift to state 161
-- On formals_opt shift to state 178
-- On formal_list shift to state 195
## Reductions:
-- On RPAREN
--   reduce production formals_opt ->

State 178:
## Known stack suffix:
## BIND ID LT typ GT LPAREN SELF formals_opt
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN SELF formals_opt . RPAREN ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RPAREN shift to state 179
## Reductions:

State 179:
## Known stack suffix:
## BIND ID LT typ GT LPAREN SELF formals_opt RPAREN
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN SELF formals_opt RPAREN . ARROW typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ARROW shift to state 180
## Reductions:

State 180:
## Known stack suffix:
## BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW . typ LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ . LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On LBRACE shift to state 182
## Reductions:

State 182:
## Known stack suffix:
## BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE . block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On WHILE shift to state 1
-- On TYPE shift to state 93
-- On RETURN shift to state 121
-- On LET shift to state 125
-- On IF shift to state 145
-- On ID shift to state 148
-- On FUN shift to state 158
-- On CONT shift to state 169
-- On BREAK shift to state 170
-- On BIND shift to state 171
-- On while_loop shift to state 183
-- On udt_def shift to state 184
-- On if_stmt shift to state 185
-- On func_def shift to state 186
-- On func_call shift to state 187
-- On declaration shift to state 188
-- On control_flow shift to state 189
-- On block_list shift to state 190
-- On block shift to state 192
-- On assignment shift to state 194
## Reductions:
-- On RBRACE
--   reduce production block_list ->

State 183:
## Known stack suffix:
## while_loop
## LR(1) items:
control_flow -> while_loop . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production control_flow -> while_loop

State 184:
## Known stack suffix:
## udt_def
## LR(1) items:
block -> udt_def . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production block -> udt_def

State 185:
## Known stack suffix:
## if_stmt
## LR(1) items:
control_flow -> if_stmt . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production control_flow -> if_stmt

State 186:
## Known stack suffix:
## func_def
## LR(1) items:
block -> func_def . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production block -> func_def

State 187:
## Known stack suffix:
## func_call
## LR(1) items:
block -> func_call . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production block -> func_call

State 188:
## Known stack suffix:
## declaration
## LR(1) items:
block -> declaration . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production block -> declaration

State 189:
## Known stack suffix:
## control_flow
## LR(1) items:
block -> control_flow . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production block -> control_flow

State 190:
## Known stack suffix:
## BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list . RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RBRACE shift to state 191
## Reductions:

State 191:
## Known stack suffix:
## BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE
## LR(1) items:
func_def -> BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production func_def -> BIND ID LT typ GT LPAREN SELF formals_opt RPAREN ARROW typ LBRACE block_list RBRACE

State 192:
## Known stack suffix:
## block
## LR(1) items:
block_list -> block . block_list [ RBRACE EOF ]
## Transitions:
-- On WHILE shift to state 1
-- On TYPE shift to state 93
-- On RETURN shift to state 121
-- On LET shift to state 125
-- On IF shift to state 145
-- On ID shift to state 148
-- On FUN shift to state 158
-- On CONT shift to state 169
-- On BREAK shift to state 170
-- On BIND shift to state 171
-- On while_loop shift to state 183
-- On udt_def shift to state 184
-- On if_stmt shift to state 185
-- On func_def shift to state 186
-- On func_call shift to state 187
-- On declaration shift to state 188
-- On control_flow shift to state 189
-- On block_list shift to state 193
-- On block shift to state 192
-- On assignment shift to state 194
## Reductions:
-- On RBRACE EOF
--   reduce production block_list ->

State 193:
## Known stack suffix:
## block block_list
## LR(1) items:
block_list -> block block_list . [ RBRACE EOF ]
## Transitions:
## Reductions:
-- On RBRACE EOF
--   reduce production block_list -> block block_list

State 194:
## Known stack suffix:
## assignment
## LR(1) items:
block -> assignment . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production block -> assignment

State 195:
## Known stack suffix:
## formal_list
## LR(1) items:
formal_list -> formal_list . COMMA ID COLON typ [ RPAREN COMMA ]
formals_opt -> formal_list . [ RPAREN ]
## Transitions:
-- On COMMA shift to state 196
## Reductions:
-- On RPAREN
--   reduce production formals_opt -> formal_list

State 196:
## Known stack suffix:
## formal_list COMMA
## LR(1) items:
formal_list -> formal_list COMMA . ID COLON typ [ RPAREN COMMA ]
## Transitions:
-- On ID shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## formal_list COMMA ID
## LR(1) items:
formal_list -> formal_list COMMA ID . COLON typ [ RPAREN COMMA ]
## Transitions:
-- On COLON shift to state 198
## Reductions:

State 198:
## Known stack suffix:
## formal_list COMMA ID COLON
## LR(1) items:
formal_list -> formal_list COMMA ID COLON . typ [ RPAREN COMMA ]
## Transitions:
-- On UNIT shift to state 98
-- On TUPLE shift to state 99
-- On STRING shift to state 101
-- On LIST shift to state 102
-- On INT shift to state 104
-- On ID shift to state 105
-- On FLOAT shift to state 106
-- On CHAR shift to state 107
-- On BOOL shift to state 108
-- On typ shift to state 199
## Reductions:

State 199:
## Known stack suffix:
## formal_list COMMA ID COLON typ
## LR(1) items:
formal_list -> formal_list COMMA ID COLON typ . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production formal_list -> formal_list COMMA ID COLON typ

State 200:
## Known stack suffix:
## FUN ID LPAREN formals_opt RPAREN ARROW typ LBRACE block_list
## LR(1) items:
func_def -> FUN ID LPAREN formals_opt RPAREN ARROW typ LBRACE block_list . RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RBRACE shift to state 201
## Reductions:

State 201:
## Known stack suffix:
## FUN ID LPAREN formals_opt RPAREN ARROW typ LBRACE block_list RBRACE
## LR(1) items:
func_def -> FUN ID LPAREN formals_opt RPAREN ARROW typ LBRACE block_list RBRACE . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production func_def -> FUN ID LPAREN formals_opt RPAREN ARROW typ LBRACE block_list RBRACE

State 202:
## Known stack suffix:
## IF expr LBRACE block_list
## LR(1) items:
if_stmt -> IF expr LBRACE block_list . RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
if_stmt -> IF expr LBRACE block_list . RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RBRACE shift to state 203
## Reductions:

State 203:
## Known stack suffix:
## IF expr LBRACE block_list RBRACE
## LR(1) items:
if_stmt -> IF expr LBRACE block_list RBRACE . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
if_stmt -> IF expr LBRACE block_list RBRACE . elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ELSE shift to state 204
-- On elif_stmt shift to state 214
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production if_stmt -> IF expr LBRACE block_list RBRACE

State 204:
## Known stack suffix:
## ELSE
## LR(1) items:
elif_stmt -> ELSE . IF expr LBRACE block_list RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
elif_stmt -> ELSE . IF expr LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
elif_stmt -> ELSE . LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On LBRACE shift to state 205
-- On IF shift to state 208
## Reductions:

State 205:
## Known stack suffix:
## ELSE LBRACE
## LR(1) items:
elif_stmt -> ELSE LBRACE . block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On WHILE shift to state 1
-- On TYPE shift to state 93
-- On RETURN shift to state 121
-- On LET shift to state 125
-- On IF shift to state 145
-- On ID shift to state 148
-- On FUN shift to state 158
-- On CONT shift to state 169
-- On BREAK shift to state 170
-- On BIND shift to state 171
-- On while_loop shift to state 183
-- On udt_def shift to state 184
-- On if_stmt shift to state 185
-- On func_def shift to state 186
-- On func_call shift to state 187
-- On declaration shift to state 188
-- On control_flow shift to state 189
-- On block_list shift to state 206
-- On block shift to state 192
-- On assignment shift to state 194
## Reductions:
-- On RBRACE
--   reduce production block_list ->

State 206:
## Known stack suffix:
## ELSE LBRACE block_list
## LR(1) items:
elif_stmt -> ELSE LBRACE block_list . RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RBRACE shift to state 207
## Reductions:

State 207:
## Known stack suffix:
## ELSE LBRACE block_list RBRACE
## LR(1) items:
elif_stmt -> ELSE LBRACE block_list RBRACE . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production elif_stmt -> ELSE LBRACE block_list RBRACE

State 208:
## Known stack suffix:
## ELSE IF
## LR(1) items:
elif_stmt -> ELSE IF . expr LBRACE block_list RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
elif_stmt -> ELSE IF . expr LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On UNIT shift to state 2
-- On SLIT shift to state 3
-- On NOT shift to state 4
-- On MATCH shift to state 5
-- On LPAREN shift to state 6
-- On LITERAL shift to state 7
-- On LBRACKET shift to state 8
-- On INCR shift to state 9
-- On ID shift to state 10
-- On FLIT shift to state 12
-- On DECR shift to state 13
-- On CLIT shift to state 14
-- On BLIT shift to state 15
-- On udt_instance shift to state 16
-- On tuple shift to state 17
-- On src_parser_list shift to state 18
-- On expr shift to state 209
## Reductions:

State 209:
## Known stack suffix:
## ELSE IF expr
## LR(1) items:
elif_stmt -> ELSE IF expr . LBRACE block_list RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
elif_stmt -> ELSE IF expr . LBRACE block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
expr -> expr . PLUS expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MINUS expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . TIMES expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DIVIDE expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . MODULO expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . EXPONENT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . INCR [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . DECR [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . BEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . NEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . LEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GT expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . GEQ expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . AND expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
expr -> expr . OR expr [ TIMES PLUS OR NEQ MODULO MINUS LT LEQ LBRACE INCR GT GEQ EXPONENT DIVIDE DECR BEQ AND ]
## Transitions:
-- On TIMES shift to state 20
-- On PLUS shift to state 24
-- On OR shift to state 32
-- On NEQ shift to state 34
-- On MODULO shift to state 22
-- On MINUS shift to state 36
-- On LT shift to state 38
-- On LEQ shift to state 40
-- On LBRACE shift to state 210
-- On INCR shift to state 26
-- On GT shift to state 42
-- On GEQ shift to state 44
-- On EXPONENT shift to state 27
-- On DIVIDE shift to state 30
-- On DECR shift to state 29
-- On BEQ shift to state 46
-- On AND shift to state 48
## Reductions:

State 210:
## Known stack suffix:
## ELSE IF expr LBRACE
## LR(1) items:
elif_stmt -> ELSE IF expr LBRACE . block_list RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
elif_stmt -> ELSE IF expr LBRACE . block_list RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On WHILE shift to state 1
-- On TYPE shift to state 93
-- On RETURN shift to state 121
-- On LET shift to state 125
-- On IF shift to state 145
-- On ID shift to state 148
-- On FUN shift to state 158
-- On CONT shift to state 169
-- On BREAK shift to state 170
-- On BIND shift to state 171
-- On while_loop shift to state 183
-- On udt_def shift to state 184
-- On if_stmt shift to state 185
-- On func_def shift to state 186
-- On func_call shift to state 187
-- On declaration shift to state 188
-- On control_flow shift to state 189
-- On block_list shift to state 211
-- On block shift to state 192
-- On assignment shift to state 194
## Reductions:
-- On RBRACE
--   reduce production block_list ->

State 211:
## Known stack suffix:
## ELSE IF expr LBRACE block_list
## LR(1) items:
elif_stmt -> ELSE IF expr LBRACE block_list . RBRACE elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
elif_stmt -> ELSE IF expr LBRACE block_list . RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RBRACE shift to state 212
## Reductions:

State 212:
## Known stack suffix:
## ELSE IF expr LBRACE block_list RBRACE
## LR(1) items:
elif_stmt -> ELSE IF expr LBRACE block_list RBRACE . elif_stmt [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
elif_stmt -> ELSE IF expr LBRACE block_list RBRACE . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On ELSE shift to state 204
-- On elif_stmt shift to state 213
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production elif_stmt -> ELSE IF expr LBRACE block_list RBRACE

State 213:
## Known stack suffix:
## ELSE IF expr LBRACE block_list RBRACE elif_stmt
## LR(1) items:
elif_stmt -> ELSE IF expr LBRACE block_list RBRACE elif_stmt . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production elif_stmt -> ELSE IF expr LBRACE block_list RBRACE elif_stmt

State 214:
## Known stack suffix:
## IF expr LBRACE block_list RBRACE elif_stmt
## LR(1) items:
if_stmt -> IF expr LBRACE block_list RBRACE elif_stmt . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production if_stmt -> IF expr LBRACE block_list RBRACE elif_stmt

State 215:
## Known stack suffix:
## WHILE expr LBRACE block_list
## LR(1) items:
while_loop -> WHILE expr LBRACE block_list . RBRACE [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
-- On RBRACE shift to state 216
## Reductions:

State 216:
## Known stack suffix:
## WHILE expr LBRACE block_list RBRACE
## LR(1) items:
while_loop -> WHILE expr LBRACE block_list RBRACE . [ WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND ]
## Transitions:
## Reductions:
-- On WHILE TYPE RETURN RBRACE LET IF ID FUN EOF CONT BREAK BIND
--   reduce production while_loop -> WHILE expr LBRACE block_list RBRACE

State 217:
## Known stack suffix:
## program_rule
## LR(1) items:
program_rule' -> program_rule . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept program_rule

State 218:
## Known stack suffix:
## block_list
## LR(1) items:
program_rule -> block_list . EOF [ # ]
## Transitions:
-- On EOF shift to state 219
## Reductions:

State 219:
## Known stack suffix:
## block_list EOF
## LR(1) items:
program_rule -> block_list EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production program_rule -> block_list EOF

